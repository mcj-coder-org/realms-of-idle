@inject IJSRuntime JSRuntime
@inject ILogger<InnGameScene> Logger
@implements IAsyncDisposable
@inherits ComponentBase
@using RealmsOfIdle.Client.UI.Components.Game
@using Microsoft.JSInterop
@using RealmsOfIdle.Core.Scenarios.Inn

<div class="inn-game-scene">
    <canvas @ref="canvasElement" id="@CanvasId" class="@GetCanvasCssClass()" style="@GetCanvasStyle()" />
    @if (ShowMinimap)
    {
        <div class="@GetMinimapCssClass()" style="@GetMinimapStyle()">
            <canvas @ref="minimapCanvas"></canvas>
            <div class="minimap-viewport"></div>
        </div>
    }
</div>

@code {
    private ElementReference canvasElement;
    private ElementReference minimapCanvas;
    private IJSObjectReference? _module;
    private DotNetObjectReference<InnGameScene>? _dotNetRef;

    [Parameter]
    public string CanvasId { get; set; } = $"inn-scene-{Guid.NewGuid()}";

    [Parameter]
    public int Width { get; set; } = 800;

    [Parameter]
    public int Height { get; set; } = 600;

    [Parameter]
    public int TileSize { get; set; } = 32;

    [Parameter]
    public InnGameViewModel ViewModel { get; set; } = null!;

    [Parameter]
    public bool ShowMinimap { get; set; } = true;

    [Parameter]
    public EventCallback<string> OnEntityClick { get; set; }

    // Animation state
    private int _animationFrame = 0;
    private bool _isAnimating = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/RealmsOfIdle.Client.UI/js/inn-game-scene.js");
            await InitializeSceneAsync();
            _dotNetRef = DotNetObjectReference.Create(this);
            _isAnimating = true;
            await RequestAnimationFrameAsync();
            Logger.LogDebug("Inn game scene initialized: {CanvasId}", CanvasId);
        }
    }

    private async Task InitializeSceneAsync()
    {
        if (_module is null) return;

        await _module.InvokeVoidAsync("initInnScene", CanvasId, Width, Height, TileSize, ShowMinimap, _dotNetRef);
    }

    [JSInvokable]
    public async Task OnAnimationFrame(double timestamp)
    {
        _animationFrame++;

        // Render scene with current game state
        if (_module is not null)
        {
            await RenderSceneAsync();
        }

        // Continue animation loop
        if (_isAnimating)
        {
            await RequestAnimationFrameAsync();
        }
    }

    private async Task RequestAnimationFrameAsync()
    {
        if (_module is not null)
        {
            await _module.InvokeVoidAsync("requestAnimationFrame", _dotNetRef);
        }
    }

    private async Task RenderSceneAsync()
    {
        if (_module is null || ViewModel is null) return;

        // Serialize game state for rendering
        var gameState = SerializeGameState();
        var customerSprites = ViewModel.GetCustomerSprites();
        var staffSprites = ViewModel.GetStaffSprites();
        var facilitySprites = ViewModel.GetFacilitySprites();

        await _module.InvokeVoidAsync("renderInnScene", CanvasId,
            gameState,
            customerSprites,
            staffSprites,
            facilitySprites,
            _animationFrame);
    }

    private string SerializeGameState()
    {
        if (ViewModel?.Layout is null) return "{}";

        // Serialize layout tiles
        var tiles = new List<object>();
        var areaIndex = 0;
        foreach (var area in ViewModel.Layout.Areas)
        {
            var grid = area.Grid;
            for (var y = 0; y < grid.Height; y++)
            {
                for (var x = 0; x < grid.Width; x++)
                {
                    var tile = grid.GetTile(x, y);
                    // Check if tile is not Empty by comparing reference equality
                    if (!ReferenceEquals(tile, TileType.Empty))
                    {
                        tiles.Add(new
                        {
                            x = x,
                            y = y,
                            type = tile.GetType().Name,
                            area = area.Id,
                            areaIndex = areaIndex
                        });
                    }
                }
            }
            areaIndex++;
        }

        return System.Text.Json.JsonSerializer.Serialize(new { tiles });
    }

    [JSInvokable]
    public async Task OnEntityClicked(string entityId, string entityType)
    {
        Logger.LogDebug("Entity clicked: {EntityId} ({EntityType})", entityId, entityType);
        await OnEntityClick.InvokeAsync(entityId);
    }

    /// <summary>
    /// Updates the scene with a new game state
    /// </summary>
    public void UpdateState(InnState newState)
    {
        ViewModel?.UpdateState(newState);
    }

    public void StopAnimation()
    {
        _isAnimating = false;
    }

    public void StartAnimation()
    {
        if (!_isAnimating)
        {
            _isAnimating = true;
            _ = RequestAnimationFrameAsync();
        }
    }

    private string GetCanvasCssClass()
    {
        return "inn-scene-canvas";
    }

    private string GetCanvasStyle()
    {
        return $"width: {Width}px; height: {Height}px;";
    }

    private string GetMinimapCssClass()
    {
        return "minimap";
    }

    private string GetMinimapStyle()
    {
        return "position: absolute; bottom: 16px; right: 16px; width: 150px; height: 150px; border: 2px solid var(--border-color); background: var(--bg-panel);";
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        StopAnimation();
        if (_dotNetRef is not null)
        {
            _dotNetRef.Dispose();
        }
        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Browser is gone, ignore
            }
        }
    }
}
