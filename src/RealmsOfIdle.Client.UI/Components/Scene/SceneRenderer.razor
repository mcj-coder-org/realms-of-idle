@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@using Microsoft.JSInterop

<canvas @ref="canvasElement" id="@CanvasId" class="@GetCssClass()" style="@GetStyle()" />
@if (ShowMinimap)
{
    <div class="@GetMinimapCssClass()" style="@GetMinimapStyle()">
        <canvas @ref="minimapCanvas"></canvas>
        <div class="minimap-viewport"></div>
    </div>
}

@code {
    private ElementReference canvasElement;
    private ElementReference minimapCanvas;
    private IJSObjectReference? _module;

    [Parameter]
    public string CanvasId { get; set; } = $"scene-{Guid.NewGuid()}";

    [Parameter]
    public int Width { get; set; } = 800;

    [Parameter]
    public int Height { get; set; } = 600;

    [Parameter]
    public int TileSize { get; set; } = 32;

    [Parameter]
    public World? World { get; set; }

    [Parameter]
    public bool ShowMinimap { get; set; } = true;

    [Parameter]
    public EventCallback<TilePosition> OnTileClick { get; set; }

    // Camera state
    private TilePosition _cameraPosition = new(0, 0);
    private TilePosition _cameraTarget = new(0, 0);
    private CameraMode _cameraMode = CameraMode.Manual;
    private TilePosition? _followTarget;

    // Animation state
    private int _animationFrame = 0;
    private double _lastTime = 0;
    private bool _isAnimating = true;
    private DotNetObjectReference<SceneRenderer>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/RealmsOfIdle.Client.UI/js/scene-renderer.js");
            await InitializeSceneAsync();
            _dotNetRef = DotNetObjectReference.Create(this);
            _isAnimating = true;
            await RequestAnimationFrameAsync();
        }
    }

    private async Task InitializeSceneAsync()
    {
        if (_module is null) return;

        await _module.InvokeVoidAsync("initScene", CanvasId, Width, Height, TileSize,
            ShowMinimap, DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async Task OnAnimationFrame(double timestamp)
    {
        _lastTime = timestamp;
        _animationFrame++;

        // Update camera (smooth interpolation)
        UpdateCamera();

        // Render scene
        if (_module is not null)
        {
            await RenderSceneAsync();
        }

        // Continue animation loop
        if (_isAnimating)
        {
            await RequestAnimationFrameAsync();
        }
    }

    private async Task RequestAnimationFrameAsync()
    {
        if (_module is not null)
        {
            await _module.InvokeVoidAsync("requestAnimationFrame", _dotNetRef);
        }
    }

    private async Task RenderSceneAsync()
    {
        if (_module is null || World is null) return;

        // Serialize tiles for rendering
        var tiles = SerializeTiles();
        await _module.InvokeVoidAsync("renderScene", CanvasId, tiles,
            _cameraPosition.X, _cameraPosition.Y, TileSize, _animationFrame);
    }

    private void UpdateCamera()
    {
        if (_cameraMode == CameraMode.Follow && _followTarget is not null)
        {
            // Smooth interpolation towards target
            var dx = _followTarget.X - _cameraPosition.X;
            var dy = _followTarget.Y - _cameraPosition.Y;

            if (Math.Abs(dx) > 0.1)
                _cameraPosition = _cameraPosition with { X = (int)(_cameraPosition.X + dx * 0.1) };

            if (Math.Abs(dy) > 0.1)
                _cameraPosition = _cameraPosition with { Y = (int)(_cameraPosition.Y + dy * 0.1) };
        }
        else
        {
            // Smooth interpolation to manual target
            var dx = _cameraTarget.X - _cameraPosition.X;
            var dy = _cameraTarget.Y - _cameraPosition.Y;

            if (Math.Abs(dx) > 0.1)
                _cameraPosition = _cameraPosition with { X = (int)(_cameraPosition.X + dx * 0.15) };

            if (Math.Abs(dy) > 0.1)
                _cameraPosition = _cameraPosition with { Y = (int)(_cameraPosition.Y + dy * 0.15) };
        }

        // Clamp to world bounds
        ClampCameraToBounds();
    }

    private void ClampCameraToBounds()
    {
        if (World is null) return;

        var maxTileX = Math.Max(0, World.Width - 1);
        var maxTileY = Math.Max(0, World.Height - 1);

        _cameraPosition = new TilePosition(
            Math.Clamp(_cameraPosition.X, 0, maxTileX),
            Math.Clamp(_cameraPosition.Y, 0, maxTileY)
        );
    }

    private async Task HandleCanvasClickAsync(int screenX, int screenY)
    {
        var tileX = (screenX / TileSize) + _cameraPosition.X;
        var tileY = (screenY / TileSize) + _cameraPosition.Y;

        await OnTileClick.InvokeAsync(new TilePosition(tileX, tileY));
    }

    public async Task SetCameraModeAsync(CameraMode mode)
    {
        _cameraMode = mode;
    }

    public async Task SetFollowTargetAsync(TilePosition? target)
    {
        _followTarget = target;
        if (target is not null)
        {
            _cameraMode = CameraMode.Follow;
        }
    }

    public async Task PanCameraAsync(Direction direction, int amount = 1)
    {
        var newPosition = _cameraPosition.Neighbor(direction);
        _cameraTarget = newPosition;
        _cameraMode = CameraMode.Manual;
    }

    public void StopAnimation()
    {
        _isAnimating = false;
    }

    public void StartAnimation()
    {
        if (!_isAnimating)
        {
            _isAnimating = true;
            _ = RequestAnimationFrameAsync();
        }
    }

    private string GetCssClass()
    {
        return "scene-canvas";
    }

    private string GetStyle()
    {
        return $"width: {Width}px; height: {Height}px;";
    }

    private string GetMinimapCssClass()
    {
        return "minimap";
    }

    private string GetMinimapStyle()
    {
        return "position: absolute; bottom: 16px; right: 16px; width: 150px; height: 150px; border: 2px solid var(--border-color); background: var(--bg-panel);";
    }

    private string SerializeTiles()
    {
        if (World is null) return "[]";

        var tiles = new List<object>();
        foreach (var area in World.Areas)
        {
            for (var y = 0; y < area.Height; y++)
            {
                for (var x = 0; x < area.Width; x++)
                {
                    var tile = area.Tiles[x, y];
                    if (tile is not null && tile.Type != TileType.Empty)
                    {
                        tiles.Add(new
                        {
                            x = area.Origin.X + x,
                            y = area.Origin.Y + y,
                            type = (int)tile.Type,
                            variant = tile.Variant,
                            decoration = tile.Decoration
                        });
                    }
                }
            }
        }
        return System.Text.Json.JsonSerializer.Serialize(tiles);
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        StopAnimation();
        if (_dotNetRef is not null)
        {
            _dotNetRef.Dispose();
        }
        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Browser is gone, ignore
            }
        }
    }
}
